#include "aes.h"

/* AES-128 specifies a 4-byte word size */
#define WORDSIZE 4
/* AES-128 uses 16 byte (4 word) keys */
#define BLKSIZE 16
/* AES-128 uses 10 rounds */
#define NUMROUNDS 10
typedef unsigned char uint8_t;

void AddRoundKey(uint8_t state[BLKSIZE], const uint8_t *w);
void SubBytes(uint8_t s[BLKSIZE]);
void ShiftRows(uint8_t s[BLKSIZE]);
void MixColumns(uint8_t s[BLKSIZE]);
void InvSubBytes(uint8_t s[BLKSIZE]);
void InvShiftRows(uint8_t s[BLKSIZE]);
void InvMixColumns(uint8_t s[BLKSIZE]);
void KeyExpansion(const uint8_t key[BLKSIZE], uint8_t w[(NUMROUNDS+1)*BLKSIZE]);
uint8_t xtime(uint8_t a);
void SubWord(uint8_t a[WORDSIZE]);
void RotWord(uint8_t a[WORDSIZE]);
uint8_t mult(uint8_t a, uint8_t b);
void Cipher(const uint8_t in[BLKSIZE], uint8_t out[BLKSIZE], uint8_t w[(NUMROUNDS+1)*BLKSIZE]);
void Decipher(const uint8_t in[BLKSIZE], uint8_t out[BLKSIZE], uint8_t w[(NUMROUNDS+1)*BLKSIZE]);

static const uint8_t sbox[256] =
{
    /*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */
      0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
     ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
     ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
     ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
     ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
     ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
     ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
     ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
     ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
     ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
     ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
     ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
     ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
     ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
     ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
     ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16
};

static const uint8_t invsbox[256] =
{
    /*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */
      0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
     ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
     ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
     ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
     ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
     ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
     ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
     ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
     ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
     ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
     ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
     ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4
     ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
     ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
     ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
     ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d
};

void SubWord(uint8_t a[WORDSIZE])
{
    a[0] = sbox[a[0]];
    a[1] = sbox[a[1]];
    a[2] = sbox[a[2]];
    a[3] = sbox[a[3]];
}

void RotWord(uint8_t a[WORDSIZE])
{
    uint8_t temp;

    temp = a[0];
    a[0] = a[1];
    a[1] = a[2];
    a[2] = a[3];
    a[3] = temp;
}

void KeyExpansion(const uint8_t key[BLKSIZE], uint8_t w[(NUMROUNDS+1)*BLKSIZE])
{
    int i,j;
    uint8_t temp[WORDSIZE];
    uint8_t Rcon[WORDSIZE] = { 1, 0, 0, 0};

    for (j=0; j < BLKSIZE; j++)
        w[j] = key[j];

    for (i = BLKSIZE; i < (NUMROUNDS+1)*BLKSIZE; i+=WORDSIZE)
    {
        for (j=0; j < WORDSIZE; j++)
            temp[j] = w[j+i-WORDSIZE];

        if ((i & 0x3*WORDSIZE) == 0)
        {
            RotWord(temp);
            SubWord(temp);
            temp[0] ^= Rcon[0];
            temp[1] ^= Rcon[1];
            temp[2] ^= Rcon[2];
            temp[3] ^= Rcon[3];
            Rcon[0] = xtime(Rcon[0]);
        }

        for (j=0; j < WORDSIZE; j++)
            w[j+i] = temp[j] ^ w[j+i-BLKSIZE];
    }
}

uint8_t xtime(uint8_t a)
{
    if (a & 0x80)
        a = (a << 1) ^ 0x1b;
    else
        a <<= 1;

    return a;
}

uint8_t mult(uint8_t a, uint8_t b)
{
    uint8_t r = 0;
    uint8_t mask;

    for (mask = 0x01; mask; mask <<= 1)
    {
        if (a & mask)
            r ^= b;
        b = xtime(b);
    }
    return r;
}

void InvMixColumns(uint8_t s[BLKSIZE])
{
    uint8_t a[WORDSIZE];
    int i;

    for (i=0; i<WORDSIZE; i++)
    {
        a[0] = s[0+WORDSIZE*i];
        a[1] = s[1+WORDSIZE*i];
        a[2] = s[2+WORDSIZE*i];
        a[3] = s[3+WORDSIZE*i];
        s[0+WORDSIZE*i] = mult(0x0e, a[0]) ^ mult(0x0b, a[1]) ^ mult(0x0d, a[2]) ^ mult(0x09,a[3]);
        s[1+WORDSIZE*i] = mult(0x0e, a[1]) ^ mult(0x0b, a[2]) ^ mult(0x0d, a[3]) ^ mult(0x09,a[0]);
        s[2+WORDSIZE*i] = mult(0x0e, a[2]) ^ mult(0x0b, a[3]) ^ mult(0x0d, a[0]) ^ mult(0x09,a[1]);
        s[3+WORDSIZE*i] = mult(0x0e, a[3]) ^ mult(0x0b, a[0]) ^ mult(0x0d, a[1]) ^ mult(0x09,a[2]);
    }
}

void MixColumns(uint8_t s[BLKSIZE])
{
    uint8_t a[WORDSIZE];
    int i;

    for (i=0; i<WORDSIZE; i++)
    {
        a[0] = s[0+WORDSIZE*i];
        a[1] = s[1+WORDSIZE*i];
        a[2] = s[2+WORDSIZE*i];
        a[3] = s[3+WORDSIZE*i];
        s[0+WORDSIZE*i] = mult(2, a[0]) ^ mult(3, a[1]) ^ a[2] ^ a[3];
        s[1+WORDSIZE*i] = mult(2, a[1]) ^ mult(3, a[2]) ^ a[3] ^ a[0];
        s[2+WORDSIZE*i] = mult(2, a[2]) ^ mult(3, a[3]) ^ a[0] ^ a[1];
        s[3+WORDSIZE*i] = mult(2, a[3]) ^ mult(3, a[0]) ^ a[1] ^ a[2];
    }
}

void InvShiftRows(uint8_t s[BLKSIZE])
{
    uint8_t temp;

    /* no change to first row */
    /* rotate second row by three */
    temp = s[1];
    s[1] = s[13];
    s[13] = s[9];
    s[9] = s[5];
    s[5] = temp;
    /* rotate third row by two */
    temp = s[2];
    s[2] = s[10];
    s[10] = temp;
    temp = s[6];
    s[6] = s[14];
    s[14] = temp;
    /* rotate fourth row by one */
    temp = s[3];
    s[3] = s[7];
    s[7] = s[11];
    s[11] = s[15];
    s[15] = temp;
}

void ShiftRows(uint8_t s[BLKSIZE])
{
    uint8_t temp;

    /* no change to first row */
    /* rotate second row by one */
    temp = s[1];
    s[1] = s[5];
    s[5] = s[9];
    s[9] = s[13];
    s[13] = temp;
    /* rotate third row by two */
    temp = s[2];
    s[2] = s[10];
    s[10] = temp;
    temp = s[6];
    s[6] = s[14];
    s[14] = temp;
    /* rotate fourth row by three */
    temp = s[3];
    s[3] = s[15];
    s[15] = s[11];
    s[11] = s[7];
    s[7] = temp;
}

void InvSubBytes(uint8_t s[BLKSIZE])
{
    int i;

    for (i=0; i<BLKSIZE; i++)
        s[i] = invsbox[s[i]];
}

void SubBytes(uint8_t s[BLKSIZE])
{
    int i;

    for (i=0; i<BLKSIZE; i++)
        s[i] = sbox[s[i]];
}

void AddRoundKey(uint8_t state[BLKSIZE], const uint8_t *w)
{
    int i;

    for (i=0; i < BLKSIZE; i++)
        state[i] ^= w[i];
}

void Cipher(const uint8_t in[BLKSIZE], uint8_t out[BLKSIZE], uint8_t w[(NUMROUNDS+1)*BLKSIZE])
{
    uint8_t state[BLKSIZE];
    int i;
    int round;

    /* copy bytes from in to state */
    for (i=0; i < BLKSIZE; i++)
        state[i] = in[i];

    AddRoundKey(state, &(w[0]));
    for (round = 1; round < 10; round++)
    {
        SubBytes(state);
        ShiftRows(state);
        MixColumns(state);
        AddRoundKey(state, &(w[BLKSIZE*round]));
    }
    SubBytes(state);
    ShiftRows(state);
    AddRoundKey(state, &(w[BLKSIZE*10]));

    /* copy bytes from state to out */
    for (i=0; i < BLKSIZE; i++)
        out[i] = state[i];
}

void Decipher(const uint8_t in[BLKSIZE], uint8_t out[BLKSIZE], uint8_t w[(NUMROUNDS+1)*BLKSIZE])
{
    uint8_t state[BLKSIZE];
    int i;
    int round;

    /* copy bytes from in to state */
    for (i=0; i < BLKSIZE; i++)
        state[i] = in[i];

    AddRoundKey(state, &(w[BLKSIZE*10]));
    for (round = 9; round; round--)
    {
        InvShiftRows(state);
        InvSubBytes(state);
        AddRoundKey(state, &(w[BLKSIZE*round]));
        InvMixColumns(state);
    }
    InvShiftRows(state);
    InvSubBytes(state);
    AddRoundKey(state, &(w[0]));

    /* copy bytes from state to out */
    for (i=0; i < BLKSIZE; i++)
        out[i] = state[i];
}

void AesEncrypt(unsigned char msg[BLKSIZE], unsigned char key[BLKSIZE])
{
    uint8_t w[(NUMROUNDS+1)*BLKSIZE];

    KeyExpansion(key, w);
    Cipher(msg, msg, w);
}

void AesDecrypt(unsigned char msg[BLKSIZE], unsigned char key[BLKSIZE])
{
    uint8_t w[(NUMROUNDS+1)*BLKSIZE];

    KeyExpansion(key, w);
    Decipher(msg, msg, w);
}

